# 智能小车待改进事项

## 1. 网络通信改进

### 1.1 UDP 通信架构问题

**当前状态：**
- 小车使用 UDP 广播发送状态数据到 `255.255.255.255:8889`
- 小车监听 `0.0.0.0:8888` 接收任何来源的控制命令
- **小车不知道服务器是谁，也没有连接管理的概念**

**问题分析：**

| 问题 | 描述 | 影响 |
|------|------|------|
| **安全隐患** | 任何局域网内的设备都能发送控制命令 | 任何人都能控制小车 |
| **多客户端冲突** | 多个控制端同时发送命令时无法区分 | 小车行为不可预测 |
| **资源浪费** | 状态数据广播给所有人 | 网络带宽浪费，干扰其他设备 |
| **无连接状态** | 无法判断服务器是否在线 | 控制端不知道小车是否可用 |

### 1.2 改进方案

**建议的架构：**

```
┌─────────────────────────────────────────────────────┐
│                    改进后架构                        │
├─────────────────────────────────────────────────────┤
│                                                     │
│   小车启动 → 广播设备存在 (255.255.255.255:8889)     │
│      ↓                                             │
│   收到第一个控制包 → 保存服务器地址                   │
│      ↓                                             │
│   已连接状态：                                       │
│      - 状态包单播给服务器 (server_ip:8889)            │
│      - 只接受来自该服务器的控制命令                   │
│      - 记录最后收到命令的时间                        │
│      ↓                                             │
│   超时检测 (如 5 秒无数据)：                          │
│      - 清除服务器地址                                │
│      - 回到广播模式，等待新连接                       │
│                                                     │
└─────────────────────────────────────────────────────┘
```

**需要修改的代码：**

1. **添加服务器连接状态管理** (`udp_service.c`)
   ```c
   // 新增全局变量
   static struct sockaddr_in g_server_addr = {0};
   static bool g_server_connected = false;
   static unsigned long long g_server_last_seen = 0;
   #define SERVER_TIMEOUT_MS 5000  // 5秒超时
   ```

2. **修改控制命令接收逻辑**
   ```c
   // 收到控制包时
   if (!g_server_connected) {
       // 首次连接：保存服务器地址
       g_server_addr = from_addr;
       g_server_connected = true;
       printf("服务器已连接: %s:%d\n", ...);
   } else {
       // 验证来源
       if (!addr_equal(&g_server_addr, &from_addr)) {
           printf("忽略来自非服务器的命令\n");
           continue;  // 丢弃包
       }
   }
   g_server_last_seen = osal_get_jiffies();
   ```

3. **修改状态发送逻辑**
   ```c
   // send_state_packet() 中
   if (g_server_connected) {
       // 单播给服务器
       sendto(sockfd, buf, len, 0, &g_server_addr, ...);
   } else {
       // 未连接：广播
       sendto(sockfd, buf, len, 0, &broadcast_addr, ...);
   }
   ```

4. **添加服务器超时检测**
   ```c
   // 主循环中
   if (g_server_connected) {
       if (now - g_server_last_seen > SERVER_TIMEOUT_MS) {
           g_server_connected = false;
           memset(&g_server_addr, 0, sizeof(g_server_addr));
           printf("服务器超时断开，重新广播...\n");
       }
   }
   ```

5. **心跳包只发给已连接的服务器**
   ```c
   // send_heartbeat() 中
   if (g_server_connected) {
       sendto(sockfd, buf, len, 0, &g_server_addr, ...);
   }
   ```

### 1.3 协议扩展（可选）

**添加握手/认证机制：**

| 类型 | 功能 | 数据格式 |
|------|------|----------|
| `0x20` | 连接请求 | 客户端 → 小车：包含客户端 ID |
| `0x21` | 连接确认 | 小车 → 客户端：包含分配的会话 ID |
| `0x22` | 心跳响应 | 双向心跳，保活连接 |

---

## 2. 按键问题

### 2.1 当前问题

**现象：** KEY1 按键按下无法切换模式

**原因分析：**
- GPIO 3 被 LED2 占用 ([boards.h:14](d:\ws63\src\drivers\boards\ws63\evb\board_config\boards.h:14))
- 按键中断注册成功，但无法触发
- 可能是系统底层初始化了 LED2，导致 GPIO 3 被占用

**临时解决方案：**
- 将按键改为 GPIO 7 (`#define ROBOT_MODE_SWITCH_GPIO 7`)
- 但需要确认开发板上 KEY1 的实际 GPIO 引脚

**长期解决方案：**
1. 查阅开发板原理图，确认 KEY1 的实际 GPIO 引脚
2. 或者禁用 LED2 的初始化代码（如果存在）

---

## 3. 校验和算法

### 3.1 当前实现

**算法：** 简单累加取低 8 位

```c
uint8_t udp_net_common_checksum8_add(const uint8_t *data, size_t len)
{
    uint8_t sum = 0;
    for (size_t i = 0; i < len; i++) {
        sum = (uint8_t)(sum + data[i]);
    }
    return sum;
}
```

**局限性：**
- 无法检测字节顺序交换
- 容易构造碰撞
- 对溢出不敏感

### 3.2 改进建议

**对于当前场景（局域网遥控）：**
- 累加校验**已够用**
- 主要目的是检测明显的传输错误，不是安全加密

**如果需要更强的完整性保护：**
- 升级为 **CRC-8**（多项式：0x07）
- 或 **CRC-16**（用于 OTA 固件升级）

---

## 4. 代码风格与一致性

### 4.1 发现的问题

| 问题 | 位置 | 说明 |
|------|------|------|
| 调试信息混入正式代码 | 多处 | `printf("[DEBUG] ...")` 应该用条件编译控制 |
| 全局变量命名不统一 | 多个文件 | `g_xxx` 风格不一致 |
| 魔法数字 | 各处 | 超时时间等应定义为宏常量 |

### 4.2 改进建议

1. **使用调试宏**
   ```c
   #ifdef DEBUG
   #define DBG_PRINT(fmt, ...) printf(fmt, ##__VA_ARGS__)
   #else
   #define DBG_PRINT(fmt, ...) ((void)0)
   #endif
   ```

2. **统一定义位置**
   - 所有超时时间常量放到 `robot_config.h`
   - 所有网络相关常量放到 `udp_service.h`

---

## 5. 优先级建议

| 优先级 | 改进项 | 工作量 | 收益 |
|--------|--------|--------|------|
| **P0** | 修复按键问题 | 小 | 用户体验 |
| **P1** | UDP 连接管理 | 中 | 安全性、网络效率 |
| **P2** | 清理调试代码 | 小 | 代码质量 |
| **P3** | 校验和升级 | 中 | 可靠性（非必需） |
| **P4** | 代码风格统一 | 小 | 可维护性 |

---

## 6. 测试建议

**改进后需要测试的场景：**

1. **连接管理测试**
   - 正常连接/断开流程
   - 服务器超时后重新连接
   - 多客户端冲突处理

2. **网络异常测试**
   - 服务器突然断电
   - 网络中断后恢复
   - WiFi 切换（2.4G ↔ 5G）

3. **安全测试**
   - 非法客户端发送控制命令
   - 重放攻击
   - 数据包篡改

---

*文档创建时间：2025-01-23*

## 7. 启动速度优化

### 7.1 当前启动时间分析

根据启动日志分析，主要耗时：

| 阶段 | 耗时 | 说明 |
|------|------|------|
| **WiFi 扫描** | ~761ms | 扫描 13 个信道，找到 18 个 AP |
| **WiFi 连接 + DHCP** | ~200ms | 连接 AP 并获取 IP 地址 |
| **射频校准** | 22ms | WiFi 射频校准（必需） |
| **其他初始化** | ~100ms | 各驱动和服务初始化 |
| **调试日志输出** | ~100ms | 串口输出大量调试信息 |
| **总计** | **~1200ms** | 从上电到 WiFi 连接成功 |

### 7.2 优化方案

| 优化项 | 预计收益 | 难度 | 优先级 |
|--------|----------|------|--------|
| **跳过 WiFi 扫描，直接连接** | -660ms | 低 | **P0** |
| 添加调试日志条件编译 | -80ms | 极低 | P2 |
| 禁用蓝牙相关代码 | -50ms | 中 | P3 |

#### 优化 1：WiFi 快速连接模式

**当前逻辑：** `bsp_wifi_connect_ap()` 每次都先扫描所有 AP，再连接目标 SSID

**优化方案：** 添加快速连接模式，跳过扫描直接连接

**需要修改：** [drivers/wifi_client/bsp_wifi.c:171-209](d:\ws63\src\drivers\wifi_client\bsp_wifi.c#L171-L209)

```c
#define WIFI_FAST_CONNECT_MODE 1  // 1=跳过扫描直接连接

int bsp_wifi_connect_ap(const char *ssid, const char *password)
{
#if WIFI_FAST_CONNECT_MODE
    // 快速连接模式：跳过扫描，直接连接
    printf("[BSP WiFi] Fast connect (no scan)...\r\n");

    expected_bss.security_type = WIFI_DEFAULT_SECURITY_TYPE;
    memcpy_s(expected_bss.ssid, WIFI_MAX_SSID_LEN, ssid, strlen(ssid));
    memcpy_s(expected_bss.pre_shared_key, WIFI_MAX_KEY_LEN, password, strlen(password));
    expected_bss.ip_type = DHCP;

    if (wifi_sta_connect(&expected_bss) != ERRCODE_SUCC) {
        printf("[BSP WiFi] Connect failed\r\n");
        return -1;
    }
#else
    // 原有扫描逻辑...
#endif
}
```

#### 优化 2：调试日志条件编译

**问题：** `[DEBUG]` 前缀的日志在发布版本中仍然输出

**解决方案：** 添加调试宏

**需要修改：** [core/robot_config.h](d:\ws63\src\application\samples\peripheral\smart_car\apps\robot_demo\core\robot_config.h)

```c
/* =============== 调试配置 =============== */
#define DEBUG_MODE_ENABLED 0  // 0=关闭调试日志, 1=开启

#if DEBUG_MODE_ENABLED
#define DBG_PRINT(fmt, ...) printf(fmt, ##__VA_ARGS__)
#else
#define DBG_PRINT(fmt, ...) ((void)0)
#endif
```

替换所有 `printf("[DEBUG] ...")` 为 `DBG_PRINT("[DEBUG] ...")`

**涉及文件：**
- [apps/robot_demo/robot_demo.c](d:\ws63\src\application\samples\peripheral\smart_car\apps\robot_demo\robot_demo.c) - 按键初始化调试日志

#### 优化 3：禁用蓝牙代码

**问题：** 日志显示 `APP|init_sle_mac failed!!!` 和 `APP|btc open`，但不需要蓝牙功能

**解决方案：** 在 Kconfig 中禁用蓝牙配置（需要确认具体配置项）

---

## 8. 已完成改进

| 日期 | 改进项 | 说明 |
|------|--------|------|
| **2025-01-26** | 代码简化 | 删除 HTTP 和 TCP 服务；简化 NV 存储为 PID 参数和 WiFi 配置；删除遥测功能；添加 PID 参数持久化 |
