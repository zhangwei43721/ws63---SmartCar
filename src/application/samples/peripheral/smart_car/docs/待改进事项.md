# 智能小车待改进事项

## 1. 网络通信改进

### 1.1 UDP 通信架构问题

**当前状态：**
- 小车使用 UDP 广播发送状态数据到 `255.255.255.255:8889`
- 小车监听 `0.0.0.0:8888` 接收任何来源的控制命令
- **小车不知道服务器是谁，也没有连接管理的概念**

**问题分析：**

| 问题 | 描述 | 影响 |
|------|------|------|
| **安全隐患** | 任何局域网内的设备都能发送控制命令 | 任何人都能控制小车 |
| **多客户端冲突** | 多个控制端同时发送命令时无法区分 | 小车行为不可预测 |
| **资源浪费** | 状态数据广播给所有人 | 网络带宽浪费，干扰其他设备 |
| **无连接状态** | 无法判断服务器是否在线 | 控制端不知道小车是否可用 |

### 1.2 改进方案

**建议的架构：**

```
┌─────────────────────────────────────────────────────┐
│                    改进后架构                        │
├─────────────────────────────────────────────────────┤
│                                                     │
│   小车启动 → 广播设备存在 (255.255.255.255:8889)     │
│      ↓                                             │
│   收到第一个控制包 → 保存服务器地址                   │
│      ↓                                             │
│   已连接状态：                                       │
│      - 状态包单播给服务器 (server_ip:8889)            │
│      - 只接受来自该服务器的控制命令                   │
│      - 记录最后收到命令的时间                        │
│      ↓                                             │
│   超时检测 (如 5 秒无数据)：                          │
│      - 清除服务器地址                                │
│      - 回到广播模式，等待新连接                       │
│                                                     │
└─────────────────────────────────────────────────────┘
```

**需要修改的代码：**

1. **添加服务器连接状态管理** (`udp_service.c`)
   ```c
   // 新增全局变量
   static struct sockaddr_in g_server_addr = {0};
   static bool g_server_connected = false;
   static unsigned long long g_server_last_seen = 0;
   #define SERVER_TIMEOUT_MS 5000  // 5秒超时
   ```

2. **修改控制命令接收逻辑**
   ```c
   // 收到控制包时
   if (!g_server_connected) {
       // 首次连接：保存服务器地址
       g_server_addr = from_addr;
       g_server_connected = true;
       printf("服务器已连接: %s:%d\n", ...);
   } else {
       // 验证来源
       if (!addr_equal(&g_server_addr, &from_addr)) {
           printf("忽略来自非服务器的命令\n");
           continue;  // 丢弃包
       }
   }
   g_server_last_seen = osal_get_jiffies();
   ```

3. **修改状态发送逻辑**
   ```c
   // send_state_packet() 中
   if (g_server_connected) {
       // 单播给服务器
       sendto(sockfd, buf, len, 0, &g_server_addr, ...);
   } else {
       // 未连接：广播
       sendto(sockfd, buf, len, 0, &broadcast_addr, ...);
   }
   ```

4. **添加服务器超时检测**
   ```c
   // 主循环中
   if (g_server_connected) {
       if (now - g_server_last_seen > SERVER_TIMEOUT_MS) {
           g_server_connected = false;
           memset(&g_server_addr, 0, sizeof(g_server_addr));
           printf("服务器超时断开，重新广播...\n");
       }
   }
   ```

5. **心跳包只发给已连接的服务器**
   ```c
   // send_heartbeat() 中
   if (g_server_connected) {
       sendto(sockfd, buf, len, 0, &g_server_addr, ...);
   }
   ```

### 1.3 协议扩展（可选）

**添加握手/认证机制：**

| 类型 | 功能 | 数据格式 |
|------|------|----------|
| `0x20` | 连接请求 | 客户端 → 小车：包含客户端 ID |
| `0x21` | 连接确认 | 小车 → 客户端：包含分配的会话 ID |
| `0x22` | 心跳响应 | 双向心跳，保活连接 |

---

## 2. 按键问题

### 2.1 当前问题

**现象：** KEY1 按键按下无法切换模式

**原因分析：**
- GPIO 3 被 LED2 占用 ([boards.h:14](d:\ws63\src\drivers\boards\ws63\evb\board_config\boards.h:14))
- 按键中断注册成功，但无法触发
- 可能是系统底层初始化了 LED2，导致 GPIO 3 被占用

**临时解决方案：**
- 将按键改为 GPIO 7 (`#define ROBOT_MODE_SWITCH_GPIO 7`)
- 但需要确认开发板上 KEY1 的实际 GPIO 引脚

**长期解决方案：**
1. 查阅开发板原理图，确认 KEY1 的实际 GPIO 引脚
2. 或者禁用 LED2 的初始化代码（如果存在）

---

## 3. 校验和算法

### 3.1 当前实现

**算法：** 简单累加取低 8 位

```c
uint8_t udp_net_common_checksum8_add(const uint8_t *data, size_t len)
{
    uint8_t sum = 0;
    for (size_t i = 0; i < len; i++) {
        sum = (uint8_t)(sum + data[i]);
    }
    return sum;
}
```

**局限性：**
- 无法检测字节顺序交换
- 容易构造碰撞
- 对溢出不敏感

### 3.2 改进建议

**对于当前场景（局域网遥控）：**
- 累加校验**已够用**
- 主要目的是检测明显的传输错误，不是安全加密

**如果需要更强的完整性保护：**
- 升级为 **CRC-8**（多项式：0x07）
- 或 **CRC-16**（用于 OTA 固件升级）

---

## 4. 代码风格与一致性

### 4.1 发现的问题

| 问题 | 位置 | 说明 |
|------|------|------|
| 调试信息混入正式代码 | 多处 | `printf("[DEBUG] ...")` 应该用条件编译控制 |
| 全局变量命名不统一 | 多个文件 | `g_xxx` 风格不一致 |
| 魔法数字 | 各处 | 超时时间等应定义为宏常量 |

### 4.2 改进建议

1. **使用调试宏**
   ```c
   #ifdef DEBUG
   #define DBG_PRINT(fmt, ...) printf(fmt, ##__VA_ARGS__)
   #else
   #define DBG_PRINT(fmt, ...) ((void)0)
   #endif
   ```

2. **统一定义位置**
   - 所有超时时间常量放到 `robot_config.h`
   - 所有网络相关常量放到 `udp_service.h`

---

## 5. 优先级建议

| 优先级 | 改进项 | 工作量 | 收益 |
|--------|--------|--------|------|
| **P0** | 修复按键问题 | 小 | 用户体验 |
| **P1** | UDP 连接管理 | 中 | 安全性、网络效率 |
| **P2** | 清理调试代码 | 小 | 代码质量 |
| **P3** | 校验和升级 | 中 | 可靠性（非必需） |
| **P4** | 代码风格统一 | 小 | 可维护性 |

---

## 6. 测试建议

**改进后需要测试的场景：**

1. **连接管理测试**
   - 正常连接/断开流程
   - 服务器超时后重新连接
   - 多客户端冲突处理

2. **网络异常测试**
   - 服务器突然断电
   - 网络中断后恢复
   - WiFi 切换（2.4G ↔ 5G）

3. **安全测试**
   - 非法客户端发送控制命令
   - 重放攻击
   - 数据包篡改

---

*文档创建时间：2025-01-23*
